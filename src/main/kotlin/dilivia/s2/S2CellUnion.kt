/**
 * This project is a kotlin port of the Google s2 geometry library (Copyright 2005 Google Inc. All Rights Reserved.):
 *                                 https://github.com/google/s2geometry.git
 *
 * Copyright Â© 2020 Dilivia (contact@dilivia.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dilivia.s2

import com.google.common.collect.Lists
import dilivia.s2.S2Cap.Companion.fromCenterHeight
import dilivia.s2.S2CellId.Companion.fromPoint
import dilivia.s2.S2CellId.Companion.lsbForLevel
import dilivia.s2.S2Point.Companion.normalize
import dilivia.s2.S2Point.Companion.plus
import dilivia.s2.S2Point.Companion.times
import java.util.*

/**
 * An S2CellUnion is a region consisting of cells of various sizes. Typically a
 * cell union is used to approximate some other shape. There is a tradeoff
 * between the accuracy of the approximation and how many cells are used. Unlike
 * polygons, cells have a fixed hierarchical structure. This makes them more
 * suitable for optimizations based on preprocessing.
 *
 */
@ExperimentalUnsignedTypes
@Strictfp
class S2CellUnion : S2Region, Iterable<S2CellId?> {
    /** The CellIds that form the Union  */
    private var cellIds = ArrayList<S2CellId>()
    fun initFromCellIds(cellIds: ArrayList<S2CellId>) {
        initRawCellIds(cellIds)
        normalize()
    }

    /**
     * Populates a cell union with the given S2CellIds or 64-bit cells ids, and
     * then calls Normalize(). The InitSwap() version takes ownership of the
     * vector data without copying and clears the given vector. These methods may
     * be called multiple times.
     */
    fun initFromIds(cellIds: ArrayList<Long>) {
        initRawIds(cellIds)
        normalize()
    }

    fun initSwap(cellIds: ArrayList<S2CellId>) {
        initRawSwap(cellIds)
        normalize()
    }

    fun initRawCellIds(cellIds: ArrayList<S2CellId>) {
        this.cellIds = cellIds
    }

    fun initRawIds(cellIds: ArrayList<Long>) {
        val size = cellIds.size
        this.cellIds = ArrayList(size)
        for (id in cellIds) {
            this.cellIds.add(S2CellId(id.toULong()))
        }
    }

    /**
     * Like Init(), but does not call Normalize(). The cell union *must* be
     * normalized before doing any calculations with it, so it is the caller's
     * responsibility to make sure that the input is normalized. This method is
     * useful when converting cell unions to another representation and back.
     * These methods may be called multiple times.
     */
    fun initRawSwap(cellIds: ArrayList<S2CellId>) {
        this.cellIds = ArrayList(cellIds)
        cellIds.clear()
    }

    fun size(): Int {
        return cellIds.size
    }

    /** Convenience methods for accessing the individual cell ids.  */
    fun cellId(i: Int): S2CellId {
        return cellIds[i]
    }

    /** Enable iteration over the union's cells.  */
    override fun iterator(): MutableIterator<S2CellId> {
        return cellIds.iterator()
    }

    /** Direct access to the underlying vector for iteration .  */
    fun cellIds(): ArrayList<S2CellId> {
        return cellIds
    }

    /**
     * Replaces "output" with an expanded version of the cell union where any
     * cells whose level is less than "min_level" or where (level - min_level) is
     * not a multiple of "level_mod" are replaced by their children, until either
     * both of these conditions are satisfied or the maximum level is reached.
     *
     * This method allows a covering generated by S2RegionCoverer using
     * min_level() or level_mod() constraints to be stored as a normalized cell
     * union (which allows various geometric computations to be done) and then
     * converted back to the original list of cell ids that satisfies the desired
     * constraints.
     */
    fun denormalize(minLevel: Int, levelMod: Int, output: ArrayList<S2CellId?>) {
        // assert (minLevel >= 0 && minLevel <= S2CellId.MAX_LEVEL);
        // assert (levelMod >= 1 && levelMod <= 3);
        output.clear()
        output.ensureCapacity(size())
        for (id in this) {
            val level = id.level()
            var newLevel = Math.max(minLevel, level)
            if (levelMod > 1) {
                // Round up so that (new_level - min_level) is a multiple of level_mod.
                // (Note that S2CellId::kMaxLevel is a multiple of 1, 2, and 3.)
                newLevel += (S2CellId.kMaxLevel - (newLevel - minLevel)) % levelMod
                newLevel = Math.min(S2CellId.kMaxLevel, newLevel)
            }
            if (newLevel == level) {
                output.add(id)
            } else {
                val end = id.childEnd(newLevel)
                var currentId = id.childBegin(newLevel)
                while (!currentId.equals(end)) {
                    output.add(currentId)
                    currentId = currentId.next()
                }
            }
        }
    }

    /**
     * If there are more than "excess" elements of the cell_ids() vector that are
     * allocated but unused, reallocate the array to eliminate the excess space.
     * This reduces memory usage when many cell unions need to be held in memory
     * at once.
     */
    fun pack() {
        cellIds.trimToSize()
    }

    /**
     * Return true if the cell union contains the given cell id. Containment is
     * defined with respect to regions, e.g. a cell contains its 4 children. This
     * is a fast operation (logarithmic in the size of the cell union).
     */
    operator fun contains(id: S2CellId?): Boolean {
        // This function requires that Normalize has been called first.
        //
        // This is an exact test. Each cell occupies a linear span of the S2
        // space-filling curve, and the cell id is simply the position at the center
        // of this span. The cell union ids are sorted in increasing order along
        // the space-filling curve. So we simply find the pair of cell ids that
        // surround the given cell id (using binary search). There is containment
        // if and only if one of these two cell ids contains this cell.
        var pos = cellIds.binarySearch(id)
        if (pos < 0) {
            pos = -pos - 1
        }
        return if (pos < cellIds.size && cellIds[pos].rangeMin().lessOrEquals(id!!)) {
            true
        } else pos != 0 && cellIds[pos - 1].rangeMax().greaterOrEquals(id!!)
    }

    /**
     * Return true if the cell union intersects the given cell id. This is a fast
     * operation (logarithmic in the size of the cell union).
     */
    fun intersects(id: S2CellId): Boolean {
        // This function requires that Normalize has been called first.
        // This is an exact test; see the comments for Contains() above.
        var pos = Collections.binarySearch(cellIds, id)
        if (pos < 0) {
            pos = -pos - 1
        }
        return if (pos < cellIds.size && cellIds[pos].rangeMin().lessOrEquals(id.rangeMax())) {
            true
        } else pos != 0 && cellIds[pos - 1].rangeMax().greaterOrEquals(id.rangeMin())
    }

    operator fun contains(that: S2CellUnion): Boolean {
        // TODO(kirilll?): A divide-and-conquer or alternating-skip-search approach
        // may be significantly faster in both the average and worst case.
        for (id in that) {
            if (!this.contains(id)) {
                return false
            }
        }
        return true
    }

    /** This is a fast operation (logarithmic in the size of the cell union).  */
    override fun contains(cell: S2Cell): Boolean {
        return contains(cell.id())
    }

    /**
     * Return true if this cell union contain/intersects the given other cell
     * union.
     */
    fun intersects(union: S2CellUnion): Boolean {
        // TODO(kirilll?): A divide-and-conquer or alternating-skip-search approach
        // may be significantly faster in both the average and worst case.
        for (id in union) {
            if (intersects(id)) {
                return true
            }
        }
        return false
    }

    fun getUnion(x: S2CellUnion, y: S2CellUnion) {
        // assert (x != this && y != this);
        cellIds.clear()
        cellIds.ensureCapacity(x.size() + y.size())
        cellIds.addAll(x.cellIds)
        cellIds.addAll(y.cellIds)
        normalize()
    }

    /**
     * Specialized version of GetIntersection() that gets the intersection of a
     * cell union with the given cell id. This can be useful for "splitting" a
     * cell union into chunks.
     */
    fun getIntersection(x: S2CellUnion, id: S2CellId) {
        // assert (x != this);
        cellIds.clear()
        if (x.contains(id)) {
            cellIds.add(id)
        } else {
            var pos = Collections.binarySearch(x.cellIds, id.rangeMin())
            if (pos < 0) {
                pos = -pos - 1
            }
            val idmax = id.rangeMax()
            val size = x.cellIds.size
            while (pos < size && x.cellIds[pos].lessOrEquals(idmax)) {
                cellIds.add(x.cellIds[pos++])
            }
        }
    }

    /**
     * Initialize this cell union to the union or intersection of the two given
     * cell unions. Requires: x != this and y != this.
     */
    fun getIntersection(x: S2CellUnion, y: S2CellUnion) {
        // assert (x != this && y != this);

        // This is a fairly efficient calculation that uses binary search to skip
        // over sections of both input vectors. It takes constant time if all the
        // cells of "x" come before or after all the cells of "y" in S2CellId order.
        cellIds.clear()
        var i = 0
        var j = 0
        while (i < x.cellIds.size && j < y.cellIds.size) {
            val imin = x.cellId(i).rangeMin()
            val jmin = y.cellId(j).rangeMin()
            if (imin.greaterThan(jmin)) {
                // Either j->contains(*i) or the two cells are disjoint.
                if (x.cellId(i).lessOrEquals(y.cellId(j).rangeMax())) {
                    cellIds.add(x.cellId(i++))
                } else {
                    // Advance "j" to the first cell possibly contained by *i.
                    j = indexedBinarySearch(y.cellIds, imin, j + 1)
                    // The previous cell *(j-1) may now contain *i.
                    if (x.cellId(i).lessOrEquals(y.cellId(j - 1).rangeMax())) {
                        --j
                    }
                }
            } else if (jmin.greaterThan(imin)) {
                // Identical to the code above with "i" and "j" reversed.
                if (y.cellId(j).lessOrEquals(x.cellId(i).rangeMax())) {
                    cellIds.add(y.cellId(j++))
                } else {
                    i = indexedBinarySearch(x.cellIds, jmin, i + 1)
                    if (y.cellId(j).lessOrEquals(x.cellId(i - 1).rangeMax())) {
                        --i
                    }
                }
            } else {
                // "i" and "j" have the same range_min(), so one contains the other.
                if (x.cellId(i).lessThan(y.cellId(j))) {
                    cellIds.add(x.cellId(i++))
                } else {
                    cellIds.add(y.cellId(j++))
                }
            }
        }
        // The output is generated in sorted order, and there should not be any
        // cells that can be merged (provided that both inputs were normalized).
        // assert (!normalize());
    }

    /**
     * Just as normal binary search, except that it allows specifying the starting
     * value for the lower bound.
     *
     * @return The position of the searched element in the list (if found), or the
     * position where the element could be inserted without violating the
     * order.
     */
    private fun indexedBinarySearch(l: List<S2CellId>, key: S2CellId, low: Int): Int {
        var low = low
        var high = l.size - 1
        while (low <= high) {
            val mid = low + high shr 1
            val midVal = l[mid]
            val cmp = midVal.compareTo(key)
            if (cmp < 0) {
                low = mid + 1
            } else if (cmp > 0) {
                high = mid - 1
            } else {
                return mid // key found
            }
        }
        return low // key not found
    }

    /**
     * Expands the cell union such that it contains all cells of the given level
     * that are adjacent to any cell of the original union. Two cells are defined
     * as adjacent if their boundaries have any points in common, i.e. most cells
     * have 8 adjacent cells (not counting the cell itself).
     *
     * Note that the size of the output is exponential in "level". For example,
     * if level == 20 and the input has a cell at level 10, there will be on the
     * order of 4000 adjacent cells in the output. For most applications the
     * Expand(min_fraction, min_distance) method below is easier to use.
     */
    fun expand(level: Int) {
        val output = ArrayList<S2CellId>()
        val levelLsb = lsbForLevel(level).toLong()
        var i = size() - 1
        do {
            var id = cellId(i)
            if (id.lsb() < levelLsb.toUInt()) {
                id = id.parent(level)
                // Optimization: skip over any cells contained by this one. This is
                // especially important when very small regions are being expanded.
                while (i > 0 && id.contains(cellId(i - 1))) {
                    --i
                }
            }
            output.add(id)
            id.appendAllNeighbors(level, output)
        } while (--i >= 0)
        initSwap(output)
    }

    /**
     * Expand the cell union such that it contains all points whose distance to
     * the cell union is at most minRadius, but do not use cells that are more
     * than maxLevelDiff levels higher than the largest cell in the input. The
     * second parameter controls the tradeoff between accuracy and output size
     * when a large region is being expanded by a small amount (e.g. expanding
     * Canada by 1km).
     *
     * For example, if maxLevelDiff == 4, the region will always be expanded by
     * approximately 1/16 the width of its largest cell. Note that in the worst
     * case, the number of cells in the output can be up to 4 * (1 + 2 **
     * maxLevelDiff) times larger than the number of cells in the input.
     */
    fun expand(minRadius: S1Angle, maxLevelDiff: Int) {
        var minLevel = S2CellId.kMaxLevel
        for (id in this) {
            minLevel = Math.min(minLevel, id.level())
        }
        // Find the maximum level such that all cells are at least "min_radius"
        // wide.
        val radiusLevel = S2CellMetrics.kMinWidth.getLevelForMinValue(minRadius.radians)
        if (radiusLevel == 0 && minRadius.radians > S2CellMetrics.kMinWidth.getValue(0)) {
            // The requested expansion is greater than the width of a face cell.
            // The easiest way to handle this is to expand twice.
            expand(0)
        }
        expand(Math.min(minLevel + maxLevelDiff, radiusLevel))
    }

    public override fun clone(): S2Region {
        val copy = S2CellUnion()
        copy.initRawCellIds(Lists.newArrayList(cellIds))
        return copy
    }
    // Compute the approximate centroid of the region. This won't produce the
    // bounding cap of minimal area, but it should be close enough.

    // Use the centroid as the cap axis, and expand the cap angle so that it
    // contains the bounding caps of all the individual cells. Note that it is
    // *not* sufficient to just bound all the cell vertices because the bounding
    // cap may be concave (i.e. cover more than one hemisphere).
    override val capBound: S2Cap
        get() {
            // Compute the approximate centroid of the region. This won't produce the
            // bounding cap of minimal area, but it should be close enough.
            if (cellIds.isEmpty()) {
                return S2Cap.empty
            }
            var centroid = S2Point(0, 0, 0)
            for (id in this) {
                val area = S2Cell.averageArea(id.level())
                centroid = plus(centroid, times(id.toPoint(), area))
            }
            centroid = if (centroid.equals(S2Point(0, 0, 0))) {
                S2Point(1, 0, 0)
            } else {
                normalize(centroid)
            }

            // Use the centroid as the cap axis, and expand the cap angle so that it
            // contains the bounding caps of all the individual cells. Note that it is
            // *not* sufficient to just bound all the cell vertices because the bounding
            // cap may be concave (i.e. cover more than one hemisphere).
            var cap = fromCenterHeight(centroid, 0.0)
            for (id in this) {
                cap = cap.addCap(S2Cell(id).capBound)
            }
            return cap
        }
    override val rectBound: S2LatLngRect
        get() {
            var bound = S2LatLngRect.empty
            for (id in this) {
                bound = bound.union(S2Cell(id).rectBound)
            }
            return bound
        }

    /** This is a fast operation (logarithmic in the size of the cell union).  */
    override fun mayIntersect(cell: S2Cell): Boolean {
        return intersects(cell.id())
    }

    /**
     * The point 'p' does not need to be normalized. This is a fast operation
     * (logarithmic in the size of the cell union).
     */
    override operator fun contains(p: S2Point): Boolean {
        return contains(fromPoint(p))
    }

    /**
     * The number of leaf cells covered by the union.
     * This will be no more than 6*2^60 for the whole sphere.
     *
     * @return the number of leaf cells covered by the union
     */
    fun leafCellsCovered(): Long {
        var numLeaves: Long = 0
        for (cellId in cellIds) {
            val invertedLevel = S2CellId.kMaxLevel - cellId.level()
            numLeaves += 1L shl (invertedLevel shl 1)
        }
        return numLeaves
    }

    /**
     * Approximate this cell union's area by summing the average area of
     * each contained cell's average area, using [S2Cell.averageArea].
     * This is equivalent to the number of leaves covered, multiplied by
     * the average area of a leaf.
     * Note that [S2Cell.averageArea] does not take into account
     * distortion of cell, and thus may be off by up to a factor of 1.7.
     * NOTE: Since this is proportional to LeafCellsCovered(), it is
     * always better to use the other function if all you care about is
     * the relative average area between objects.
     *
     * @return the sum of the average area of each contained cell's average area
     */
    fun averageBasedArea(): Double {
        return S2Cell.averageArea(S2CellId.kMaxLevel) * leafCellsCovered()
    }

    /**
     * Calculates this cell union's area by summing the approximate area for each
     * contained cell, using [S2Cell.approxArea].
     *
     * @return approximate area of the cell union
     */
    fun approxArea(): Double {
        var area = 0.0
        for (cellId in cellIds) {
            area += S2Cell(cellId).approxArea()
        }
        return area
    }

    /**
     * Calculates this cell union's area by summing the exact area for each
     * contained cell, using the [S2Cell.exactArea].
     *
     * @return the exact area of the cell union
     */
    fun exactArea(): Double {
        var area = 0.0
        for (cellId in cellIds) {
            area += S2Cell(cellId).exactArea()
        }
        return area
    }

    /** Return true if two cell unions are identical.  */
    override fun equals(that: Any?): Boolean {
        if (that !is S2CellUnion) {
            return false
        }
        return cellIds == that.cellIds
    }

    override fun hashCode(): Int {
        var value = 17
        for (id in this) {
            value = 37 * value + id.hashCode()
        }
        return value
    }

    /**
     * Normalizes the cell union by discarding cells that are contained by other
     * cells, replacing groups of 4 child cells by their parent cell whenever
     * possible, and sorting all the cell ids in increasing order. Returns true if
     * the number of cells was reduced.
     *
     * This method *must* be called before doing any calculations on the cell
     * union, such as Intersects() or Contains().
     *
     * @return true if the normalize operation had any effect on the cell union,
     * false if the union was already normalized
     */
    fun normalize(): Boolean {
        // Optimize the representation by looking for cases where all subcells
        // of a parent cell are present.
        val output = ArrayList<S2CellId>(cellIds.size)
        output.ensureCapacity(cellIds.size)
        cellIds.sort()
        for (id in this) {
            var currentId = id
            var size = output.size
            // Check whether this cell is contained by the previous cell.
            if (!output.isEmpty() && output[size - 1].contains(currentId)) {
                continue
            }

            // Discard any previous cells contained by this cell.
            while (!output.isEmpty() && currentId.contains(output[output.size - 1])) {
                output.removeAt(output.size - 1)
            }

            // Check whether the last 3 elements of "output" plus "id" can be
            // collapsed into a single parent cell.
            while (output.size >= 3) {
                size = output.size
                // A necessary (but not sufficient) condition is that the XOR of the
                // four cells must be zero. This is also very fast to test.
                if (output[size - 3].id xor output[size - 2].id xor output[size - 1].id != currentId.id) {
                    break
                }

                // Now we do a slightly more expensive but exact test. First, compute a
                // mask that blocks out the two bits that encode the child position of
                // "id" with respect to its parent, then check that the other three
                // children all agree with "mask.
                var mask = (currentId.lsb() shl 1).toLong()
                mask = (mask + (mask shl 1)).inv()
                val idMasked = (currentId.id and mask.toULong())
                if (output[size - 3].id and mask.toULong() != idMasked
                        || output[size - 2].id and mask.toULong() != idMasked
                        || output[size - 1].id and mask.toULong() != idMasked
                        || currentId.isFace()) {
                    break
                }

                // Replace four children by their parent cell.
                output.removeAt(size - 1)
                output.removeAt(size - 2)
                output.removeAt(size - 3)
                currentId = currentId.parent()
            }
            output.add(currentId)
        }
        if (output.size < size()) {
            initRawSwap(output)
            return true
        }
        return false
    }
}